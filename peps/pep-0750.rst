PEP: 750
Title: Template Strings
Author: Jim Baker <jim.baker@python.org>, Guido van Rossum <guido@python.org>, Paul Everitt <pauleveritt@me.com>
Sponsor: Lysandros Nikolaou <lisandrosnik@gmail.com>
Discussions-To: https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408
Status: Draft
Type: Standards Track
Created: 08-Jul-2024
Python-Version: 3.14

Abstract
========

This PEP introduces template strings for custom string processing.

Template strings are a generalization of f-strings, using a ``t`` in place of 
the ``f`` prefix. Instead of evaluating to ``str``, t-strings evaluate to a new 
type, ``types.Template``. Templates provide developers with access to the string 
and its interpolated values *before* they are combined. This opens up the 
possibility of safety checks, web templating, domain-specific languages, and 
many other forms of flexible string processing.


Relationship With Other PEPs
============================

Python introduced f-strings in Python 3.6 with :pep:`498`. The grammar was
then formalized in :pep:`701` which also lifted some restrictions. This PEP
is based off of PEP 701.

At nearly the same time PEP 498 arrived, :pep:`501` was written to provide
"i-strings" -- that is, "interpolation template strings". The PEP was
deferred pending further experience with f-strings. Work on this PEP was
resumed by a different author in March 2023, introducing "t-strings" as template
literal strings, and built atop PEP 701.

The authors of this PEP consider it to be a generalization and simplification
of the updated work in PEP 501. (That PEP has also recently been updated to
reflect the new ideas in this PEP.)


Motivation
==========

Python f-strings are easy to use and very popular. Over time, however, developers
have encountered limitations that make them unsuitable for certain use cases. 
In particular, f-strings provide no way to intercept and transform interpolated 
values before they are combined into a final string.

As a result, incautious use of f-strings can lead to security vulnerabilities. 
For example, a user executing a SQL query with `sqlite3 <https://docs.python.org/3/library/sqlite3.html>`__
may be tempted to use an f-string to embed values into their SQL expression 
instead of using the ``?`` placeholder and passing the values as a tuple to 
avoid a `SQL injection attack <https://en.wikipedia.org/wiki/SQL_injection>`__.

More broadly, the inability to transform interpolated values before they are
combined into a final string limits the utility of f-strings in more complex
string processing tasks. 

Template strings address these problems by providing 
developers with access to the string and its interpolated values before they 
are combined. 

For example, imagine we want to generate some HTML. Using template 
strings, we can define an ``html`` function that allows us to automatically 
sanitize interpolated values:

.. code-block:: python

    evil = "<script>alert('evil')</script>"
    template = t"<p>{evil}</p>"
    assert html(template) == '<p>&lt;script&gt;alert(&#x27;evil&#x27;)&lt;/script&gt;</p>'

Likewise, our hypothetical ``html()`` can make it easy for developers to add 
attributes to HTML elements using a dictionary:

.. code-block:: python

    attributes = {"src": "shrubbery.jpg", "alt": "looks nice"}
    template = t"<img {attributes} />"
    assert html(template) == '<img src="shrubbery.jpg" alt="looks nice" />'

Neither of these examples is possible with today's f-strings. By providing a 
mechanism to intercept and transform interpolated values, template strings
enable a wide range of string processing use cases.


Specification
=============

Template string literals
------------------------

This PEP introduces a new string prefix, ``t``, to define template string literals.
These literals resolve to a new type, ``types.Template``.

The following code creates a ``Template`` instance:

.. code-block:: python

    from types import Template
    template = t"This is a template string."
    assert isinstance(template, Template)

Template string literals support the full syntax of :pep:`701`. This includes
the ability to nest template strings within interpolations, as well as the ability
to use any quote mark in the string literal. Like other string prefixes, the template
prefix must immediately precede the quote mark. Like f-strings, both lowercase 
``t`` and uppercase ``T`` prefixes are supported. Like f-strings, t-strings may
not be combined with the ``b`` or ``u`` prefixes. 


The ``Template`` type
---------------------

Template strings evaluate to an instance of a new type, ``Template``, found
in the ``types`` module:

.. code-block:: python

    @dataclass(frozen=True, match_args=True)
    class Template:
        args: Sequence[str | Interpolation]

The ``args`` attribute provides access to the string parts and
any interpolations in the literal:

.. code-block:: python

    name = "World"
    template = t"Hello {name}"

    assert len(template.args) == 3  # Three parts: ["Hello ", "{name}", ""]
    assert template.args[0] == "Hello "  # String before "{name}"
    assert template.args[1].value == "World". # Value of "{name}"
    assert template.args[2] == ""  # String after "{name}"

    assert isinstance(template.args[0], str)
    assert isinstance(template.args[1], Interpolation)
    assert isinstance(template.args[2], str)


The ``Interpolation`` type
--------------------------

The ``Interpolation`` type represents an expression inside a template string. 
Like ``Template``, it is a new concrete type found in the ``types`` module:

.. code-block:: python

    @dataclass(frozen=True, match_args=True)
    class Interpolation:
        value: Any
        expr: str
        format_spec: str = ""
        conv: Literal["a", "r", "s"] | None = None

The ``value`` attribute is the evaluated result of the interpolation:

.. code-block:: python

    name = "World"
    template = t"Hello {name}"
    assert template.args[1].value == "World"

The ``expr`` attribute is the *original text* of the interpolation:

.. code-block:: python

    name = "World"
    template = t"Hello {name}"
    assert template.args[1].expr == "name"

The ``format_spec`` attribute is the `format specification <https://docs.python.org/3/library/string.html#format-specification-mini-language>`_.
As with f-strings, this is an arbitrary string that defines how to present the value:

.. code-block:: python

    value = 42.0
    template = t"Value: {value:.2f}"
    assert template.args[1].format_spec == ".2f"

If no format specification is provided, ``format_spec`` defaults to an empty 
string (``""``). This matches the ``format_spec`` parameter of Python's 
`format() <https://docs.python.org/3/library/functions.html#format>`_ built-in.

The ``conv`` attribute is the `optional conversion <https://docs.python.org/3/library/string.html#format-string-syntax>`_
to be used, one of ``r``, ``s``, and ``a``, corresponding to repr, str, and ascii 
conversions. As with f-strings, no other conversions are supported:

.. code-block:: python

    name = "World"
    template = t"Hello {name!r}"
    assert template.args[1].conv == "r"

If no conversion is provided, ``conv`` is ``None``. 

Unlike f-strings, it is up to code that processes the template to determine how to
interpret the ``conv`` and ``format_spec`` attributes. It is not required that they
be used in any particular way, but it is recommended that they be respected when
present and, to the extent possible, match the behavior of f-strings. It would
be surprising if, for example, a template string that uses ``{value:.2f}`` did not
round the value to two decimal places when processed.


Processing template strings
---------------------------

Developers can write arbitrary code to process template strings. For example,
the following function renders static parts of the template in lowercase and
interpolations in uppercase:

.. code-block:: python

    from types import Template, Interpolation

    def lower_upper(template: Template) -> str:
        """Render static parts lowercased and interpolations uppercased."""
        parts: list[str] = []
        for arg in template.args:        
            if isinstance(arg, Interpolation):
                parts.append(str(arg.value).upper())
            else:
                parts.append(arg.lower())
        return "".join(parts)

    name = "world"
    assert lower_upper(t"HELLO {name}") == "hello WORLD"

There is no requirement that template strings are processed in any particular 
way. Code that processes templates has no obligation to return a string. 
Template strings are a flexible, general-purpose feature.

See the `Common Patterns Seen In Processing Templates`_ section for more
information on how to process template strings.


No support for concatenation
----------------------------

Because template strings are designed to be used in custom DSLs, they do not
support explicit concatenation using ``+``. This is unlike all other string
literals in Python today. Concatenation may have different semantics in 
different DSLs or no meaningful semantics at all; accordingly, the ``Template`` 
type that t-strings evaluate to does not support ``__add__`` or similar methods.

The following code will raise a ``TypeError``:

.. code-block:: python

    t"Hello " + t"World"

Implicit concatenation is also not supported. The following code will raise 
a ``SyntaxError``:

.. code-block:: python

    t"Hello " "World"


Support for the debug specifier
-------------------------------

The debug specifier, ``=``, is supported in template strings but behaves 
slightly differently than in f-strings. The specifier
was introduced in `gh-80998 <https://github.com/python/cpython/issues/80998>`_
outside of any PEP. The distinction in behavior is due to technical limitations
of the implementation.

In particular, ``t'{expr=}'`` is treated as ``t'expr={expr}'``:

.. code-block:: python

    name = "World"
    template = t"Hello {name=}"
    assert template.args[0] == "Hello name="
    assert template.args[1].value == "World"


Raw template strings
--------------------

Raw template strings are supported using the ``rt`` prefix:

.. code-block:: python

    trade = 'shrubberies'
    t = rt'Did you say "{trade}"?\n'
    assert t.args[0] == r'Did you say "'
    assert t.args[2] == r'"?\n'

In this example, the ``\n`` is treated as two separate characters 
(a backslash followed by 'n') rather than a newline character. This is 
consistent with Python's raw string behavior.

As with regular template strings, interpolations in raw template strings are 
processed normally, allowing for the combination of raw string behavior and 
dynamic content.


Interpolation expression evaluation
-----------------------------------

Expression evaluation for interpolations is the same as in :pep:`498#expression-evaluation`:

    The expressions that are extracted from the string are evaluated in the context
    where the template string appeared. This means the expression has full access to its
    lexical scope, including local and global variables. Any valid Python expression
    can be used, including function and method calls.

Template strings are evaluated eagerly from left to right, just like f-strings. This means that
interpolations are evaluated immediately when the template string is processed, not deferred
or wrapped in lambdas.


Exceptions
----------

Exceptions raised in t-string literals are essentially the same as those raised in f-strings.


Interleaving of ``Template.args``
---------------------------------

As a detail of the ``Template`` type, the ``args`` attribute is a sequence that
alternates between string literals and ``Interpolation`` instances. Specifically:

- Even-indexed elements (0, 2, 4, ...) are always of type ``str``, representing the literal parts of the template.
- Odd-indexed elements (1, 3, 5, ...) are always ``Interpolation`` instances, representing the interpolated expressions.

For example, the following assertions hold:

.. code-block:: python

    name = "World"
    template = t"Hello {name}"
    assert template.args[0] == "Hello "
    assert template.args[1].value == "World"
    assert template.args[2] == "" 

These rules imply that the ``args`` attribute will always have an odd length:

.. code-block:: python

    a = "a"
    template = t"{a}"
    assert len(template.args) == 3
    assert template.args[0] == ""
    assert template.args[1].value == "a"
    assert template.args[2] == ""

Most template processing code will not care about this detail and will use 
either structural pattern matching or ``isinstance()`` checks to distinguish 
between the two types of elements in the sequence. 

The detail exists because it allows for performance optimizations in template
processing code. For example, a template processor could cache the static parts
of the template and only reprocess the dynamic parts when the template is
evaluated with different values. Access to the static parts can be done with
``template.args[::2]``.


Example: Structured Logging
===========================

**TODO** this is a key section that we still need to write.

It will show how to use t-strings in tandem with the `logging` module to create
a structured logging system. Hopefully this will both motivate the utility of
t-strings and provide a good example of how to use them in a real-world application.

**TODO**
**TODO**
**TODO**


Tool Support
============

Python semantics in template strings
------------------------------------

**TODO** still trying to decide how to revise this section...

Python template languages and other DSLs have semantics quite apart from Python.
Different scope rules, different calling semantics e.g. for macros, their own
grammar for loops, and the like.

This means all tools need to write special support for each language. Even then,
it is usually difficult to find all the possible scopes, for example to autocomplete
values.

However, f-strings do not have this issue. An f-string is considered part of Python.
Expressions in curly braces behave as expected and values should resolve based on
regular scoping rules. Tools such as mypy can see inside f-string expressions,
but will likely never look inside a Jinja2 template.

DSLs written with template strings will inherit much of this value. While we can't expect
standard tooling to understand the "domain" in the DSL, they can still inspect
anything expressible in an f-string.

Backwards Compatibility
=======================

Like f-strings, use of template strings will be a syntactic backwards incompatibility
with previous versions.

Security Implications
=====================

The security implications of working with interpolations, with respect to
interpolations, are as follows:

1. Scope lookup is the same as f-strings (lexical scope). This model has been
   shown to work well in practice.

2. Code that processes ``Template`` instances can ensure that any interpolations 
   are processed in a safe fashion, including respecting the context in the 
   target DSL.


How To Teach This
=================

Template strings have several audiences: developers using template strings
and processing libraries, authors of template processing code, and framework
authors who provide interesting machinery built with template strings.

All three groups can start from an important framing:

- Existing solutions (such as template engines) can do parts of template strings
- But template strings move logic closer to "normal Python"

Consumers can look at template strings as starting from f-strings:

- They look familiar
- Scoping and syntax rules are the same

The first thing they need to absorb: unlike f-strings, template string literals
don't evaluate to strings; rather, they evaluate to a new type, ``Template``.
``Template`` is a simple type intended to be used by template processing code.
It's not until you call that code that you get the result you want: typically,
a string, although processing code can of course return any arbitrary type.

Template function authors think in terms of making a DSL. They have
business policies they want to provide in a Python-familiar way. With template
functions, Python is going to do much of the pre-processing. This lowers
the bar for making a DSL.

Template authors can begin with simple use cases. After authors gain experience, template strings can be used to add larger
patterns: lazy evaluation, intermediate representations, registries, and more.

Each of these points also match the teaching of decorators. In that case,
a learner consumes something which applies to the code just after it. They
don't need to know too much about decorator theory to take advantage of the
utility.


Common Patterns Seen In Processing Templates
============================================

Structural pattern matching
---------------------------

Iterating over the ``Template.args`` with structural pattern matching is the expected
best practice for many template function implementations:

.. code-block:: python

    from types import Template, Interpolation

    def process(template: Template) -> Any:
        for arg in template.args:
            match arg:
                case str() as s:
                    ... # handle each string part
                case Interpolation() as interpolation:
                    ... # handle each interpolation


Processing code may also commonly sub-match on attributes of the ``Interpolation`` type:

.. code-block:: python

    match arg:
        case Interpolation(int()):
            ... # handle interpolations with integer values
        case Interpolation(value=str() as s):
            ... # handle interpolations with string values
        # etc.


Memoizing
---------

Template functions can efficiently process both static and dynamic parts of templates.
The structure of ``Template`` objects allows for effective memoization:

.. code-block:: python

    source = template.args[::2]  # Static string parts
    values = [i.value for i in template.args[1::2]]  # Dynamic interpolated values

This separation enables caching of processed static parts, while dynamic parts can be
inserted as needed. Authors of template processing code can use the static `source` 
as cache keys, leading to significant performance improvements when similar 
templates are used repeatedly.


Parsing to intermediate representations
---------------------------------------

Code that processes templates can parse the template string into intermediate
representations, like an AST. We expect that many template processing libraries
will use this approach.

For instance, rather than returning a ``str``, our theoretical ``html()`` function
(see the `Motivation`_ section) could return an ``HTMLElement`` defined in the 
same package:

.. code-block:: python

    def html(template: Template) -> HTMLElement:
        ...

Calling ``str(element)`` would then render the HTML but, in the meantime, the
``HTMLElement`` could be manipulated in a variety of ways.


Context-sensitive processing of interpolations
----------------------------------------------

Continuing with our hypothetical ``html()`` function, it could be made 
context-sensitive. Interpolations could be processed differently depending 
on where they appear in the template. 

For example, our ``html()`` function could support multiple kinds of
interpolations:

.. code-block:: python

    attributes = {"id": "main"}
    trade = "shrubbery"
    content = "hello"
    template = t"<div {attributes} data-trade={trade}>{content}</div>"
    assert str(html(template)) == '<div id="main" data-trade="shrubbery">hello</div>'

Because the ``{attributes}`` interpolation occurs in the context of an HTML tag,
and because there is no corresponding attribute name, it is treated as a dictionary
of attributes. The ``{trade}`` interpolation is treated as a simple string value
and is quoted before inclusion in the final string. The ``{content}`` 
interpolation is treated as potentially unsafe content and is escaped before 
inclusion in the final string.


Nested template strings
-----------------------

Going a step further with our ``html()`` function, we could support nested
template strings. This would allow for more complex HTML structures to be
built up from simpler templates:

.. code-block:: python

    name = "World"
    content = html(t"<p>Hello {name}</p>")
    template = t"<div>{content}</div>"
    assert str(html(template)) == '<div><p>Hello World</p></div>'

Because the ``{content}`` interpolation is an ``HTMLElement`` instance, it does
not need to be escaped before inclusion in the final string.

One could imagine a nice simplification: if the ``html()`` function is passed
a ``Template`` instance, it could automatically process it as an ``HTMLElement``
by recursively calling itself on the nested template.


Approaches to lazy evaluation
-----------------------------

Like f-strings, interpolations in t-string literals are eagerly evaluated. However,
there are cases where lazy evaluation may be desirable.

If a single interpolation is expensive to evaluate, it can be explicitly wrapped
in a ``lambda`` in the template string literal:

.. code-block:: python

    name = "World"
    template = t"Hello {lambda: name}"
    assert template.args[1].value() == "World"

This assumes, of course, that template processing code anticipates that some
interpolation values may be callable. This is not a requirement of the PEP, 
but it is a common pattern in template processing code.

If the template processing code does not explicitly support lazy evaluation, 
but _does_ by default call Python's ``format()`` built-in, a clever developer 
could use a ``__format__`` dunder to force lazy evaluation of the interpolation:

.. code-block:: python

    class on_format:
        def __init__(self, callable: Callable[[], Any]):
            self._callable = callable

        def __format__(self, format_spec: str) -> str:
            return format(self._callable(), format_spec)

    name = "World"
    assert process(t"Hello {on_format(lambda: name)}") == "Hello World"

In general, we hope that the community will develop best practices for lazy
evaluation of interpolations in template strings and that, when it makes sense,
common libraries will provide support for callable ``value`` in their template
processing code.


Approaches to template reuse
----------------------------

If developers wish to reuse template strings multiple times with different 
values, they can write a function to return a ``Template`` instance:

.. code-block:: python

    def reusable(name: str, question: str) -> Template:
        return t"Hello {name}, {question}?"

    template = reusable("friend", "how are you")
    template = reusable("King Arthur", "what is your quest")

This is, of course, no different from how f-strings can be reused.


Reference Implementation
========================

At the time of this PEP's announcement, a fully-working implementation is
`available <https://github.com/lysnikolaou/cpython/tree/tag-strings-rebased>`_.

This implementation is not final, as the PEP discussion will likely provide changes.


Rejected Ideas
==============

This PEP has been through several significant revisions. In addition, quite a few interesing
ideas were considered both in revisions of :pep:`501` and in the `Discourse discussion <https://discuss.python.org/t/pep-750-tag-strings-for-writing-domain-specific-languages/60408/196>`_.

We attempt to document the most significant ideas that were considered and rejected.


Arbitrary string literal prefixes
---------------------------------

Inspired by `JavaScript tagged template literals <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates>`_,
an ealier version of this PEP allowed for arbitrary "tag" prefixes in front
of literal strings:

.. code-block:: python

    my_tag'Hello {name}'

The prefix was a special callable called a "tag function" that received the 
equivalent of this PEP's ``Template.args``, processed it, and returned an arbitrary
value:

.. code-block:: python

    def my_tag(*args: str | Interpolation) -> Any:
        ...

This approach was rejected for several reasons:

- It was deemed too complex to build in full generality. JavaScript allows for 
  arbitrary expressions to precede a template string, which is a significant 
  challenge to implement in Python.
- It precluded future introduction of new string prefixes.
- It seemed to needlessly pollute the namespace.

Use of a single ``t`` prefix was chosen as a simpler, more Pythonic approach and 
more in keeping with template strings' role as a generalization of f-strings.


Delayed evaluation of interpolations
------------------------------------

An early version of this PEP proposed that interpolations should be lazily 
evaluated. All interpolations were "wrapped" in implicit lambdas. Instead of 
having an eagerly evaluated ``value`` attribute, interpolations had a 
``getvalue()`` method that would resolve the value of the interpolation:

.. code-block:: python

    class Interpolation:
        ...
        _value: callable[[], Any]

        def getvalue(self) -> Any:
            return self._value()

This was rejected for several reasons:

- The overwhelming majority of use cases for template strings naturally call
  for immediate evaluation.
- Delayed evaluation would be a significant departure from the behavior of 
  f-strings.
- Implicit lambda wrapping leads to difficulties with type hints and 
  static analysis.

Most importantly, there are viable (if imperfect) alternatives to implicit 
lambda wrapping when lazy evaluation is desired. See the section on 
`Approaches to lazy evaluation`_, above, for more information.


Making ``Template`` and ``Interpolation`` into protocols
--------------------------------------------------------

An early version of this PEP proposed that the ``Template`` and ``Interpolation``
types be runtime checkable protocols rather than concrete types. 

In the end, we felt that using concrete types was more straightforward.


An additional ``Decoded`` type
------------------------------

An early version of this PEP proposed an additional type, ``Decoded``, to represent
the "static string" parts of a template string. This type derived from ``str`` and
had a single extra ``raw`` attribute that provided the original text of the string.
We rejected this in favor of the simpler approach of using plain ``str`` and
allowing combination of ``r`` and ``t`` prefixes.
        

Enable full reconstruction of original template literal
-------------------------------------------------------

Earlier versions of this PEP attempted to make it possible to fully reconstruct
the text of the original template string from a ``Template`` instance. This was 
rejected as being overly complex.

There are several limitations with respect to round-tripping to the original
source text:

- ``Interpolation.format_spec`` defaults to ``""`` if not provided. It is therefore
  impossible to distinguish ``t"{expr}"`` from ``t"{expr:}"``.
- The debug specifier, ``=``, is treated as a special case. It is therefore not
  possible to distinguish ``t"{expr=}"`` from ``t"expr={expr}"``.
- Finally, format specifiers in f-strings allow arbitrary nesting. In this PEP 
  and in the reference implementation, the specifier is eagerly evaluated 
  to set the ``format_spec`` in the ``Interpolation``, thereby losing 
  the original expressions. For example:

.. code-block:: python

    spec = ".2f"
    value = 42
    template = t"{value:{spec}}"
    assert template.args[1].format_spec == ".2f"

We do not anticipate that these limitations will be a significant issue in practice.
Developers who need to obtain the original template string literal can always
use ``inspect.getsource()`` or similar tools.


String concatenation
--------------------

Implicit template string concatenation isn't supported, which is `unlike all other string literals
<https://docs.python.org/3/reference/lexical_analysis.html#string-literal-concatenation>`_.

The expectation is that triple quoting is sufficient. If implicit string
concatenation is supported, results from template evaluations would need to
support the ``+`` operator with ``__add__`` and ``__radd__``.

Because template strings target embedded DSLs, this complexity introduces other
issues, such as determining appropriate separators. This seems unnecessarily
complicated and is thus rejected.


Arbitrary conversion values
---------------------------

Python allows only ``r``, ``s``, or ``a`` as possible conversion type values.
Trying to assign a different value results in ``SyntaxError``.

In theory, template functions could choose to handle other conversion types. But this
PEP adheres closely to :pep:`701`. Any changes to allowed values should be in a
separate PEP.


Mechanism to describe the "kind" of template
--------------------------------------------

If t-strings prove popular, it may be useful to have a way to describe the
"kind" of content found in a template string: "sql", "html", "css", etc. 
This could enable powerful new features in tools such as linters, formatters, 
type checkers, and IDEs. (Imagine, for example, ``black`` formatting HTML in 
t-strings, or ``mypy`` checking whether a given attribute is valid for an HTML 
tag.) While exciting, this PEP does not propose any specific mechanism. It is 
our hope that, over time, the community will develop conventions for this purpose.


Acknowledgements
================

Thanks to Ryan Morshead for contributions during development of the ideas leading
to template strings. Thanks also to Koudai Aono for infrastructure work on contributing
materials. Special mention also to Dropbox's `pyxl <https://github.com/dropbox/pyxl>`_
as tackling similar ideas years ago.

Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
